// solves wordle puzzle using known words
// Terminal setup: transmit CR for newline, local echo off, 38400

#include "thesau94.h"

// 128 bytes are
byte ramBuffer[128];
char buchs[26];  // letter + -
char ist[6];     // actual wort
char muss[6];    // letters which must be in wort
char exac[6];    // position known e.g. a**ch
byte exacP;
char nicht[26][5]; // letter not allowed at
uint16_t wfnd;      //worte found
uint16_t lcnt[26];  // letter counts generated by z

enum instat_t {norm, plus, minus, leer, punkt, match, exakt};
instat_t instat;
uint16_t inp;
bool inpAkt = false;
byte ilc; // input letter count 1..5
unsigned long currMs, prevMs = 0;
bool verbo = false;
bool autom = false; // search after cr
byte showMode = 7; // 0: show results per page, else in blocks of 7, switch with m
byte showCnt;

// Memory saving helpers
void prnt(PGM_P p) {
  // flash to serial until \0
  while (1) {
    char c = pgm_read_byte(p++);
    if (c == 0) break;
    Serial.write(c);
  }
  Serial.write(' ');
}

void msgF(const __FlashStringHelper *ifsh, uint16_t n) {
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  prnt(p);
  Serial.println(n);
}

void prnF(const __FlashStringHelper *ifsh) {
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  prnt(p);
}

void prlnF(const __FlashStringHelper *ifsh) {
  prnF(ifsh);
  Serial.println();
}

void copyBeis(uint8_t  n) {
  if (n < anzBeis) {
    byte i = 0;
    byte b = !0;
    while (b != 0) {
      b = pgm_read_byte(&beis[n][i]);
      ramBuffer[i++] = b;
    }
  }
}

void initBuchs() {
  memset (buchs, ' ', sizeof(buchs));
  memset (nicht, ' ', sizeof(nicht));
  memset (exac, '*', 5);
}

bool hatNicht(byte n) {
  // reurns true if at least one found for letter n
  if (buchs[n] != ' ') return true;
  for ( byte i = 0; i < 5; i++)   {
    if (nicht[n][i] != ' ') return true;
  }
  return false;
}

void showNicht() {
  char str[50];
  prlnF(F("     1 2 3 4 5"));
  for (byte i = 0; i < 26; i++)   {
    if (hatNicht(i)) {
      sprintf(str, "%1c %1c  %1c %1c %1c %1c %1c  ", char(i + 'a'), buchs[i], nicht[i][0], nicht[i][1], nicht[i][2], nicht[i][3], nicht[i][4]);
      Serial.println(str);
    }
  } // next i
  for ( byte i = 0; i < 5; i++)   {
    Serial.write(exac[i]);
  }
  Serial.println();
  prepareMuss();
  showMuss();
}

void showMuss() {
  for ( byte i = 0; i < 6; i++)   {
    if (muss[i] == 0) {
      Serial.println("<");
      return;
    }
    Serial.write(muss[i]);
    Serial.write(' ');
  }
  Serial.println("??");
}

void prepareMuss() {
  // buchs to  muss
  byte m = 0;
  for ( byte i = 0; i < 26; i++)   {
    if (buchs[i] == '+' ) {
      muss[m] = i + 'a';
      m++;
      if (m > 4) break;
    }
  } // next
  muss[m] = 0;
}

void showBuff() {
  for ( byte i = 0; i < 128; i++)   {
    if (i % 80 == 0) Serial.println();
    if (ramBuffer[i] == 0) {
      Serial.println("<<");
      return;
    }
    Serial.write(ramBuffer[i]);
    if (i % 5 == 4) Serial.write(' ');
  } //next
}


void setLeer(byte n) {
  buchs[n] = ' ';
  for ( byte i = 0; i < 5; i++) {
    nicht[n][i] = ' ';
  }
}

void setNicht(byte n, char c) {
  buchs[n] = '-';
  for ( byte i = 0; i < 5; i++) {
    nicht[n][i] = c;
  }
}

void setPunkt(char c, byte s) {
  if (s > 0 and s < 6) {
    nicht[c - 'a'][s - 1] = c;
  } else {
    msgF(F("Punkt 1..5 aber"), s);
  }
}

bool checkMuss() {
  // true if ist and muss
  bool found;
  for ( byte m = 0; m < 5; m++) {
    if (muss[m] == 0 ) return true;
    found = false;
    for ( byte i = 0; i < 5; i++) {
      if (muss[m] == ist[i]) {
        found = true;
        break;
      }
    } // next i
    if (!found) return false;
  } // next j
  return true;
}

bool checkExac() {
  // true if ist and exac
  for ( byte i = 0; i < 5; i++) {
    if (exac[i] != '*' ) {
      if (exac[i] != ist[i]) return false;
    }
  } // next i
  return true;
}

bool checkIst() {
  if (checkMuss()) {
    if (checkExac()) {
      if (verbo) {
        Serial.write('!');
      } else { // show found
        for ( byte j = 0; j < 5; j++)   {
          Serial.write(ist[j]);
        }
        Serial.write(' ');
      }
      return true;
    } else {
      if (verbo) Serial.write('E');
      return false;
    }
  } else { // muss fail
    if (verbo) Serial.write('M');
    return false;
  }
}

void checkBuff() {
  // compare with nicht
  byte ic = 0; // letter in wort
  char c;
  byte  found = 0;
  for ( byte i = 0; i < 128; i++)   {
    c = ramBuffer[i];
    if (c == 0) {
      if (showMode==0 and found > 0) Serial.println("<<");
      return;
    }
    if (verbo) Serial.write(c);
    if (nicht[c - 'a'][ic] == c) { // not allowed, jump to next wort
      i += (4 - ic);
      if (verbo) Serial.write('#');
      ic = 0;
    } else {
      ist[ic] = c;
      ic++;
      if (ic > 4) { //wort in ist  ist zulässig
        if (checkIst()) {
          found ++;
          wfnd++;
          if (showMode > 0) {
            showCnt--;
            if (showCnt == 0) {
              Serial.println();
              showCnt = showMode;
            }
          }
        }
        ic = 0;
      } // zulässig
    } // allowed
  } //next
}

void doLoop(uint16_t n) {
  unsigned long anfMs, endMs;
  anfMs = millis();
  prepareMuss();
  wfnd = 0;
  showCnt = showMode;
  if (n == 0) n = anzBeis;
  if (n > anzBeis) n = anzBeis;
  for ( byte b = 0; b < n; b++) {
    copyBeis(b);
    checkBuff();
  }
  endMs = millis();
  Serial.println();
  Serial.print(n);
  prnF(F(" pages searched"));
  Serial.print(wfnd);
  prnF(F(" worte found in"));
  Serial.print(endMs - anfMs);
  prlnF(F(" ms"));
}

void countBuff() {
  // compare with nicht
  char c;
  for ( byte i = 0; i < 128; i++)   {
    c = ramBuffer[i];
    if (c == 0) {
      return;
    }
    lcnt[c - 'a']++;
  }
}

void doZahl(uint16_t n) {
  unsigned long anfMs, endMs;
  char str[50];
  anfMs = millis();
  if (n == 0) n = anzBeis;
  if (n > anzBeis) n = anzBeis;
  for ( byte i = 0; i < 26; i++)   {
    lcnt[i] = 0;
  }
  for ( byte b = 0; b < n; b++) {
    copyBeis(b);
    countBuff();
  }
  endMs = millis();
  prnF(F("Letter count took "));
  Serial.println(endMs - anfMs);

  float tot = 0;
  uint16_t totu;
  float prc;
  for ( byte i = 0; i < 26; i++)   {
    tot += lcnt[i];
  }
  totu = round(tot);

  for ( byte i = 0; i < 26; i++)   {
    prc = lcnt[i];
    prc = prc / tot;
    prc = prc * 100;
    uint16_t pru = round(prc);
    sprintf(str, "%1c %6u     %2u  ", char(i + 'a'), lcnt[i], pru);
    Serial.println(str);
  }
  sprintf(str, "  %6u  ", totu);
  Serial.println(str);
}

// syntax
// -abc  verbieten
// +abc  muss
// #abc  egal
// =a*b**     exakt 5!
// 0..9 zu inp
// b beispiel -> flash
// d suche laut drin
// e suche laut exac
// n suche laut nidri

void prompt() {
  instat = norm;
  ilc = 1;
  if (autom) Serial.print("A>"); else Serial.print("N>");
}

bool switchStat(byte tmp) {
  switch (tmp) {
    case '+':   // must
      instat = plus;
      return true;
    case '-':   // not allowed
      instat = minus;
      return true;
    case '.':   // must, but not here
      instat = punkt;
      return true;
    case '\\':   // remove
      instat = leer;
      return true;
    case '#':   // must here
      instat = match;
      return true;
    case '=':   //
      instat = exakt;
      exacP = 0;
      return true;
    case 13:
      if (autom) doLoop(0);
      prompt();
      return true;
  }
  return false;
}

bool handleStat(byte tmp) {
  if (tmp <'a' or tmp >'z') {
    Serial.println("nicht a-z");
    prompt();
    return true;
  }
  switch (instat) {
    case plus:
      buchs[tmp - 'a'] = '+';
      break;
    case  minus:
      setNicht(tmp - 'a', tmp);
      break;
    case punkt:
      setPunkt(tmp, ilc);
      buchs[tmp - 'a'] = '+';
      break;
    case leer:
      setLeer(tmp - 'a');
      break;
    case match:
      buchs[tmp - 'a'] = '+';
      exac[ilc - 1] = tmp;
      break;
    case exakt:
      exac[exacP++] = tmp;
      break;
    default:
      return false;
  }
  ilc++;
  return true;
}

void doCmd(byte tmp) {
  Serial.print(char(tmp));
  if ((tmp >= '0') && (tmp <= '9')) { // Ziffern
    if (inpAkt) {
      inp = inp * 10 + (tmp - '0');
    } else {
      inpAkt = true;
      inp = tmp - '0';
    }
    return;
  }
  inpAkt = false;

  if (switchStat(tmp)) return;

  if (instat == exakt) {
    if (exacP > 4) {
      Serial.println("<<");
      prompt();
      return;
    }
    if ( tmp == '*') {
      exac[exacP++] = tmp;
      return;
    }
  }

  if (handleStat(tmp)) return;

  switch (tmp) {
    case 'a':   //
      autom = !autom;
      prnF(F("utom "));
      if (autom) prlnF(F("an")); else  prlnF(F("aus"));
      break;
    case 'b':   //
      copyBeis(inp);
      showBuff();
      break;
    case 'c':   //
      showBuff();
      break;
    case 'i':   //
      prlnF(F("nit"));
      initBuchs();
      break;
    case 'l':   //
      prlnF(F("oop"));
      doLoop(0);
      break;
    case 'm':   //
      showMode = inp;
      msgF(F("ode is "), showMode);
      break;
    case 'p':   //
      prlnF(F("ruf"));
      prepareMuss();
      checkBuff();
      break;
    case 's':   //
      prlnF(F("how"));
      showNicht();
      break;
    case 'v':   //
      verbo = !verbo;
      prnF(F("erbose "));
      if (verbo)  prlnF(F("an")); else  prlnF(F("aus"));
      break;
    case 'z':   //
      prlnF(F("ahl"));
      doZahl(inp);
      break;
    default:
      msgF(F("??  -a.b#c, +, =, \\, 0..9, init, loop, verbose, autom, show, help "), tmp);
      prlnF(F("pruf, zahl, nnnblock, nnmode"));
  } //case
  prompt();
}

void setup() {
  const char info[] = "wort5 " __DATE__  " " __TIME__;
  Serial.begin(38400);
  Serial.println(info);
  msgF(F("beisp"), sizeof(beis));
  initBuchs();
  prompt();
}


void loop() {
  if (Serial.available() > 0) {
    doCmd( Serial.read());
  } // serial

  currMs = millis();
  if (currMs - prevMs > 1000) {
    prevMs = currMs;
  } // timer
}
