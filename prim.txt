known primes:
one-byte are provided on compile-time:
#define ANZPR8 55
const static unsigned char PROGMEM prim8 [ANZPR8]
two-byte are in flash in chunks of 128 which can be programmed into flash by optiboot on the fly.
two byte b1 b2 occurs 64 
three byte b1,b2,b3 occurs 42(!)
four byte b1,b2,b3,b4 occurs 32
A chunk is generated by finding first valid start after given number and then filling up additional primes.
a two-byte chunk of 64 primes takes about 50ms to generate as it's only required to divide by the known one byte primes.

Vorgang							Slave					Sla			Master sendet

Initialisieren+tops				doInit(topPrim)        	4801y		Yb8       

einen chunk ab num	>topPage	generate(num) 			255g		Gb8

teach-in anz ab topPrim			teachIn16(anz)			30t			-
von Page 1

en Bloc:  0y30t, topPrim ermitteln dann nächsten Slave
alternierend	abwechselnd jedem Slave

Abfragen														Antwort
Index erste prim jedes chunks 	doIndex(chu)					5		b8b8b8b8...08
beginnend ab chu max 		


Master:  sendeZahl('G',inp) 
Slave :  receiveHandle
Master:  check state until !B
		 request topPrim (highest written prime) 
The teach-in allows to fill n subsequent 


Ziel war es, eine wirklich nutzlose Maschine zu bauen, in der Mikroprozessoren sich von der alltäglichen Langeweile erholen können.
Welcher Prozessor könnte dazu besser geeignet sein als ein ATMega328p?
Mit der brutalstmögliche Taktfrequenz von 16 MHz wird ein elaboriertes Rechenwerk angetrieben, eingebettet in die laufzeitoptimierte Arduino-Umgebung.  
Für Experten sonnenklar, das ist erste Sahne. Jetzt arbeiten hier aber nicht ein oder gar zwei, nein 15 dieser leistungshungrigen Einheiten kämpfen gemeinsam.
Woran? Alle Primzahlen kleiner 1 Billion (amerikanisch) für die Nachwelt auf einer SD-Karte zu verewigen. 
Verbunden sind sie über den ultraschnellen TWI-Bus (TWBR 12!). Die Kämpfer sind nicht alle gleich, wir haben je einen Dirigenten (Codename Majestro), einen Kommunikator (eingespart)
und einen Chronisten. Die übrigen sind die Kalkulatoren, spezialisiert auf (Typ 2, 3 und 4).
Es können bis zu 127 Kämpfer eingesetzt werden, allerdings verbieten die aktuellen Preise für die Arduino Mini Pros den weiteren Ausbau.

Alle können über serielle Schnittstelle von ihrer Arbeit berichten oder Anweisungen entgegennehmen.
Das passiert mit dezenten 38400 baud, um den PC nicht zu überfordern. 

Um Primes bis  1.000.000.000 (3B9ACA0) zu finden muss man sie nur durch alle 3347 Primes bis 31.623 teilen. Das sind 55 pages zu 128 bytes
und passt locker in den enormen Flash-Speicher.
Ablauf: jeder Rechner kennt die 55 Primzahlen <255. 
Die Kalkulatoren vom Typ 2 bringen sich die 2-byte Primzahlen von 257 bis 31623 selbst bei und merken sie sich für die nächsten 100 Jahre (optiboot machts möglich).
Das dauert vier Sekunden und ist nur nach einem allfälligen Software-Update erforderlich.
Majestro fragt den Chronisten nach der top-Prime ("wo waren wir stehengeblieben?") und macht sich munter ans Werk.
An jeden 2-er schickt er einen zu überprüfenden Bereich, der antwortet wieviele (für ihn) Prims darin gefunden wurden.
Falls Prims gefunden wurden holt der Majestro diese ab und schickt sie an den Chronisten, der sie hoffentlich ordnungsgemäß verbucht.

Typischer Ablauf nach Einschalten, Terminal mit Majestro:

O 		Zeige Anwesende:
       epr  adr typ   S R  Tsk
 > 1    11   11   2   I c    0
   2    12   12   2   I c    0
j 		Top Prim der Slaves:
Target 11  Top prim 33.359
Target 12  Top prim 33.359
...

33333b	Wir fangen mit 33333 an
   St  Slv Srt S R
 1  W    0  2      33.333
 2  W    0  2      33.353
 3  W    0  2      33.373
...
Zeigt Taskliste, viele warten, ganz rechts der Bereich-Anfang. Ein Bereich umfasst also 20 (?)

1Y		schreibe Primes in Logfile 1
Check  3 B 1
Check  3 O 1
Der erste Check mit 'B' zeigt dass der Chronist Beschäftigt ist und zur Zeit nicht gestört werden möchte
der zweite Check mit 'O' zeigt dass alles in Ordnung ist (Checks mit O werden i.d.R nicht gezeigt, nur B und E)

X		dann man los
...
Check  3 O 1
addPrime 33.493
Check  3 O 1
addPrime 33.503
Check  3 O 1
addPrime 33.521
Check  3 O 1

x		und anhalten. das Ganze ist ja ziemlich lahm. Das liegt daran, dass der Majestro sich nur jede Sekunde
 um das Orchester kümmert, das sieht man mit
 
Übrigens: Die Zahlen in der Datei sind nicht in Reihenfolge, weil die Feststellung der Prim-heit 
41771
41863
41579
41879
41887
41893


Im Netz gibt es eine List of prime numbers up to 1 000 000 000 000 (1000 billion) die zur Validierung herangezogen wurde:
mySql anlegen
	CREATE TABLE `primes` (`num` INT(10) UNSIGNED NOT NULL,	PRIMARY KEY (`num`) USING BTREE);
als Textfile Anzahl 600 herunterladen
in notepad:
	Speichern unter 
	edit/EOL Conversion/Unix
	\t ersetzen durch \n 
	erste Zeile löschen (falls doppelt)
	Speichern unter 
in mysql:	
	LOAD DATA INFILE 'c:/greed/prim257_.txt' IGNORE INTO TABLE primes;
	

Kenner werden hier sofort an die 1 Million Sudoko games (https://www.kaggle.com/bryanpark/sudoku) denken, an denen diese Konfiguration bereits gearbeitet hat.
Auch die 3 Millionen (https://www.kaggle.com/radcliffe/3-million-sudoku-puzzles-with-ratings) oder die 9 Millionen (https://www.kaggle.com/rohanrao/sudoku) sind machbar,
	

Aber das System kann noch mehr: Für jede Zahl bis  werden blitzartig die Primfaktoren ermittelt.
 

Orte
C:\Users\hh\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\2.1


BOOTSZ	Size   Pages	Application			BootL				End App
1	1	256 words	4	0x0000 - 0x3EFF		0x3F00 - 0x3FFF		0x3EFF 		0x3F00
1	0	512 words	8	0x0000 - 0x3DFF		0x3E00 - 0x3FFF		0x3DFF		0x3E00
0	1  1024 words  16	0x0000 - 0x3BFF		0x3C00 - 0x3FFF		0x3BFF		0x3C00
0	0  2048 words  32	0x0000 - 0x37FF		0x3800 - 0x3FFF		0x37FF		0x3800
(RWW)   224 			0x0000 - 0x37FF
(NRWW)   32				0x3800 - 0x3FFF

